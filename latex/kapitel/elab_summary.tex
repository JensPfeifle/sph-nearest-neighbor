
\chapter{Summary and Outlook}


Increasingly stringent efficiency and emissions requirements for commercial turbofan engines have spurred the development of geared engine designs. To master the challenge presented by these engines in the form of gearbox cooling and lubrication, accurate and efficient simulation tools are currently being developed and improved. The smoothed-particle hydrodynamics method (SPH) is one such computational fluid dynamics tool that is used to evaluate the flow and distribution of oil in such a gearbox. The goal of this work was to examine an approach to increasing the computational efficiency of an SPH solver.

As a particle-based method, SPH requires an interaction-search step, where the solver determines which particles in the computational domain interact with each other. The approach in this work targets this interaction search step, which is mathematically a fixed-radius near-neighbor search. Currently, the solver uses the cell linked-lists method. It was expected that in sparsely-filled computational domains with few particles, other methods would have a performance advantage over the CLL method in the form of reduced run time or memory use.

To examine this hypothesis, a benchmarking framework was developed in which different search methods can be evaluated without running the full SPH code. The tracked values include the runtime of the search process or individual sections of the process, and the maximum memory use of the process. A modular approach was chosen in which the test cases, search methods, and results evaluation code can be replaced as required. 

The search methods are implemented in the same programming language as the SPH code, C++. They read in a list of particles representing a test case, and evaluate the neighbor search. The search methods include additional timing code to enable monitoring of the runtime. In addition to the CLL method, a C++ library called {\itshape ANN}, which implements a kd-tree data structure specifically for point neighbor searches, is evaluated. A third library, {\itshape nanoflann}, is mentioned but was not evaluated in detail due to time constraints.

Various test cases are generated using Python scripts. The test cases differ in two ways. First in the fill percentage, or how much of the domain contains particles. The second differentiating factor is the fill type, or how these points are distributed in the domain. For example, fewer but larger clusters of particles are expected to have different properties for neighbor searches then many clusters containing fewer particles. Clusters with boundaries that are not orthogonal or parallel to the edges of the domain are also tested.

After evaluating each of the test cases with the CLL and ANN search methods, it is immediately apparent that the ANN search method is much more computationally expensive than the CLL method in all test cases. This is due to the interaction pair list generation step, which must be completed separately when using ANN. Even with this step removed from the code (see ANN-NL results), the ANN method is significantly slower than the existing CLL method, which already includes the interaction list generation step. Futhermore, the CLL method uses about one-half of the amount of memory that the ANN method requires.

In addition to the comparison between the CLL and ANN methods. The effect of the parameters fill percentage and fill type were evaluated. Generally, processing time and memory use increases with the fill percentage due to the larger number of particles to be processed. The CLL method is not significantly influenced by the fill type. The ANN method is more sensitive and performs better (less memory and lower runtime) as the clusters get smaller. An influence of the cluster boundary orientation (orthogonal/parallel or diagonal) was seen, with diagonal boundaries leading to worse serach performance. However, due to the limited number of test cases this can not be definitively stated as fact without a more thorough examination.

Overall, the results show that the ANN search method approach does not yield any kind of performance improvement for the SPH simulation. The neighbor search itself is significantly slower than the CLL method. Even if the search itself were faster, the additionally required list processing step as implemented here is extremely  expensive computationally. In the current version of the SPH solver, which requires the interaction pair lists, the ANN method is not usable.

In future work, the Nanoflann library should be evaluated more closely. If the Nanoflann library is faster than the ANN library, and if the SPH code can be refactored to make better use of the kd-tree data structure, performance improvements for sparse domains are still conceivable.  Specifically, nanoflann theoretically supports updating parts of the search structure instead of rebuilding the entire structure. Alternative data storage methods such as bd-trees may also yield increased performance over kd-trees. For this and other alternative approaches, this work provides a good basis for further investigation.